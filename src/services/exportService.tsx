// /src/services/exportService.ts
import { ProjectData, MetricScore, BatchSummary } from '@/types';

export class ExportService {
  // ============= CSV EXPORT =============
  static exportMetricsToCSV(metrics: Record<string, MetricScore>, projectName: string): void {
    const rows = Object.entries(metrics).map(([metricName, metric]) => ({
      Metric: this.formatMetricName(metricName),
      Score: metric.score,
      Status: metric.status.toUpperCase(),
      Confidence: `${metric.confidence}%`,
      Weight: `${this.getMetricWeight(metricName)}%`,
      Flags: metric.flags?.map((f: any) => f.description).join('; ') || 'None',
      Submetrics: metric.breakdown?.subMetrics?.map((sm: any) => `${sm.name}: ${sm.score}`).join('; ') || 'N/A'
    }));

    this.exportToCSV(rows, `${this.sanitizeFilename(projectName)}_metrics.csv`);
  }

  static exportBatchToCSV(projects: Array<{name: string, riskScore: number, verdict: string, redFlags: string[]}>) {
    const rows = projects.map(project => ({
      Project: project.name,
      'Risk Score': project.riskScore,
      Verdict: project.verdict.toUpperCase(),
      'Top Red Flag': project.redFlags[0] || 'None',
      'Flag Count': project.redFlags.length,
      Recommendation: this.getRecommendationFromScore(project.riskScore)
    }));

    this.exportToCSV(rows, `batch_analysis_${new Date().toISOString().split('T')[0]}.csv`);
  }

  // ============= JSON EXPORT =============
  static exportProjectAnalysis(projectData: ProjectData): void {
    const exportData = {
      metadata: {
        projectName: projectData.displayName,
        scannedAt: projectData.scannedAt?.toISOString() || new Date().toISOString(),
        riskScore: projectData.overallRisk.score,
        verdict: projectData.overallRisk.verdict,
        confidence: projectData.overallRisk.confidence,
        processingTime: projectData.processingTime
      },
      overallRisk: projectData.overallRisk,
      metrics: projectData.metrics,
      sources: Object.keys(projectData.sources || {}).filter(key => projectData.sources?.[key as keyof typeof projectData.sources]),
      generatedAt: new Date().toISOString(),
      version: 'Sifter 1.2'
    };

    this.exportToJSON(exportData, `${this.sanitizeFilename(projectData.displayName)}_analysis.json`);
  }

  // ============= PDF EXPORT =============
  static exportToPDF(content: string, filename: string = 'sifter_report.pdf'): void {
    try {
      // Create a simple text file that can be saved as .pdf
      // In a real implementation, you would use a PDF library like jsPDF or pdf-lib
      const pdfContent = this.generatePDFContent(content);
      this.downloadFile(pdfContent, filename, 'application/pdf');
    } catch (error) {
      console.error('PDF export failed:', error);
      // Fallback: create a text file instead
      this.downloadFile(content, filename.replace('.pdf', '.txt'), 'text/plain');
    }
  }

  static exportResearchReport(projectData: ProjectData): void {
    const reportContent = this.generateResearchReport(projectData);
    this.exportToPDF(reportContent, `${this.sanitizeFilename(projectData.displayName)}_research_report.pdf`);
  }

  // ============= SIMPLE PDF FOR DASHBOARD =============
  static exportSimplePDF(projectData: ProjectData): void {
    const report = `
      SIFTER RESEARCH REPORT
      =====================
      
      Project: ${projectData.displayName}
      Analysis Date: ${new Date().toLocaleDateString()}
      Risk Score: ${projectData.overallRisk.score}/100
      Verdict: ${projectData.overallRisk.verdict.toUpperCase()}
      Confidence: ${projectData.overallRisk.confidence}%
      
      METRIC BREAKDOWN:
      ----------------
      ${Object.entries(projectData.metrics).map(([key, metric]: [string, any]) => 
        `${this.formatMetricName(key)}: ${metric.score}/100 (${metric.status})`
      ).join('\n')}
      
      SUMMARY:
      --------
      ${projectData.overallRisk.summary}
      
      =====================
      Generated by Sifter
      ${new Date().toLocaleString()}
    `;
    
    this.exportToPDF(report.trim(), `${this.sanitizeFilename(projectData.displayName)}_report.pdf`);
  }

  // ============= GENERIC FILE EXPORT =============
  private static exportToCSV(data: any[], filename: string): void {
    if (!data || data.length === 0) {
      console.error('No data to export');
      return;
    }

    const headers = Object.keys(data[0]);
    const csvRows = [
      // Headers
      headers.join(','),
      // Data rows
      ...data.map(row => 
        headers.map(header => {
          const value = row[header];
          return this.escapeCSVValue(value);
        }).join(',')
      )
    ];

    const csvString = csvRows.join('\n');
    this.downloadFile(csvString, filename, 'text/csv;charset=utf-8;');
  }

  private static exportToJSON(data: any, filename: string): void {
    const jsonString = JSON.stringify(data, null, 2);
    this.downloadFile(jsonString, filename, 'application/json');
  }

  private static downloadFile(content: string, filename: string, mimeType: string): void {
    try {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.style.display = 'none';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Clean up the URL object after download
      setTimeout(() => URL.revokeObjectURL(url), 100);
    } catch (error) {
      console.error('Download failed:', error);
      // Fallback method
      const link = document.createElement('a');
      link.href = 'data:' + mimeType + ',' + encodeURIComponent(content);
      link.download = filename;
      link.click();
    }
  }

  // ============= PDF CONTENT GENERATION =============
  private static generatePDFContent(textContent: string): string {
    // Create HTML content that can be styled for better readability
    const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <title>SIFTER Research Report</title>
    <style>
        body { 
            font-family: 'Courier New', monospace;
            margin: 40px;
            line-height: 1.6;
            color: #333;
        }
        .header {
            text-align: center;
            border-bottom: 3px double #333;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .subtitle {
            font-size: 14px;
            color: #666;
        }
        .section {
            margin: 20px 0;
        }
        .section-title {
            font-size: 18px;
            font-weight: bold;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            margin-bottom: 15px;
        }
        .metric-row {
            margin: 8px 0;
            padding-left: 20px;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            font-size: 12px;
            color: #666;
            text-align: center;
        }
        pre {
            white-space: pre-wrap;
            font-family: inherit;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">SIFTER RESEARCH REPORT</div>
        <div class="subtitle">AI-Powered Crypto Project Analysis Platform</div>
    </div>
    <div class="content">
        <pre>${textContent.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
    </div>
    <div class="footer">
        Generated by Sifter 1.2 â€¢ ${new Date().toLocaleString()} â€¢ https://sifter.app
    </div>
</body>
</html>`;

    return htmlContent;
  }

  private static generateResearchReport(projectData: ProjectData): string {
    const metrics = Object.entries(projectData.metrics)
      .map(([key, metric]: [string, any]) => {
        return `${this.formatMetricName(key)}: ${metric.score}/100 (${metric.status.toUpperCase()})`;
      })
      .join('\n');

    return `
PROJECT: ${projectData.displayName}
ANALYSIS DATE: ${projectData.scannedAt?.toLocaleDateString() || new Date().toLocaleDateString()}
RISK SCORE: ${projectData.overallRisk.score}/100
VERDICT: ${projectData.overallRisk.verdict.toUpperCase()}
CONFIDENCE: ${projectData.overallRisk.confidence}%

EXECUTIVE SUMMARY
-----------------
${projectData.overallRisk.summary}

METRIC BREAKDOWN
----------------
${metrics}

DETAILED ANALYSIS
-----------------
${this.generateDetailedAnalysis(projectData)}

RECOMMENDATION
--------------
${this.getRecommendationFromScore(projectData.overallRisk.score)}

GENERATED: ${new Date().toLocaleString()}
VERSION: Sifter 1.2 Research Edition
`;
  }

  private static generateDetailedAnalysis(projectData: ProjectData): string {
    let analysis = '';
    
    // Check for critical metrics
    const criticalMetrics = Object.entries(projectData.metrics)
      .filter(([_, metric]: [string, any]) => metric.score >= 80)
      .map(([key, _]) => this.formatMetricName(key));
    
    if (criticalMetrics.length > 0) {
      analysis += `CRITICAL RISKS DETECTED:\nâ€¢ ${criticalMetrics.join('\nâ€¢ ')}\n\n`;
    }

    // Add contaminated network details if present
    if (projectData.metrics.contaminatedNetwork?.score >= 60) {
      analysis += 'NETWORK CONTAMINATION:\nâ€¢ Connected to known bad actors\nâ€¢ Historical pattern of failures\n\n';
    }

    // Add team identity concerns
    if (projectData.metrics.teamIdentity?.score >= 60) {
      analysis += 'TEAM CONCERNS:\nâ€¢ Anonymous or pseudonymous team members\nâ€¢ Limited professional verification\n\n';
    }

    return analysis;
  }

  // ============= PARTNER PACKET GENERATION (For EA Mode) =============
  static generatePartnerPacket(batchSummary: BatchSummary, selectedProjects: ProjectData[]) {
    const packet = {
      summary: batchSummary,
      projects: selectedProjects.map(p => ({
        name: p.displayName,
        riskScore: p.overallRisk.score,
        verdict: p.overallRisk.verdict,
        topRedFlag: this.getTopRedFlag(p.metrics),
        processingTime: p.processingTime
      })),
      generatedAt: new Date().toISOString(),
      recommendations: this.generatePartnerRecommendations(batchSummary)
    };

    return packet;
  }

  static exportPartnerPacket(packet: any, filename: string = 'partner_packet.json'): void {
    this.exportToJSON(packet, filename);
  }

  private static getTopRedFlag(metrics: Record<string, MetricScore>): string {
    const criticalMetrics = Object.entries(metrics)
      .filter(([_, metric]) => metric.score >= 80)
      .sort((a, b) => b[1].score - a[1].score);
    
    if (criticalMetrics.length > 0) {
      const [metricName, metric] = criticalMetrics[0];
      return `${this.formatMetricName(metricName)} (${metric.score}/100)`;
    }
    
    return 'No critical red flags detected';
  }

  private static generatePartnerRecommendations(batchSummary: BatchSummary): string[] {
    const recommendations: string[] = [];
    
    if (batchSummary.rejected > batchSummary.total * 0.5) {
      recommendations.push('High rejection rate (>50%) - Consider stricter screening criteria');
    }
    
    if (batchSummary.passed < batchSummary.total * 0.1) {
      recommendations.push('Low pass rate (<10%) - Pipeline quality may need improvement');
    }
    
    if (batchSummary.averageRiskScore > 60) {
      recommendations.push(`High average risk (${batchSummary.averageRiskScore}/100) - Market conditions may be risky`);
    }
    
    return recommendations;
  }

  // ============= WORKFLOW INTEGRATION =============
  static async sendToWebhook(webhookUrl: string, data: any, integrationType?: 'slack' | 'teams' | 'generic'): Promise<boolean> {
    try {
      let payload = data;
      
      // Format for specific platforms
      if (integrationType === 'slack') {
        payload = this.formatForSlack(data);
      } else if (integrationType === 'teams') {
        payload = this.formatForTeams(data);
      }

      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      return response.ok;
    } catch (error) {
      console.error('Webhook error:', error);
      return false;
    }
  }

  private static formatForSlack(projectData: ProjectData): any {
    const riskColor = projectData.overallRisk.score >= 80 ? '#ff0000' :
                     projectData.overallRisk.score >= 60 ? '#ff9900' :
                     projectData.overallRisk.score >= 40 ? '#ffff00' : '#00ff00';

    return {
      attachments: [{
        color: riskColor,
        title: `ðŸ”¬ Sifter Analysis: ${projectData.displayName}`,
        fields: [
          {
            title: 'Risk Score',
            value: `${projectData.overallRisk.score}/100`,
            short: true
          },
          {
            title: 'Verdict',
            value: projectData.overallRisk.verdict.toUpperCase(),
            short: true
          },
          {
            title: 'Summary',
            value: projectData.overallRisk.summary?.substring(0, 100) + '...' || 'No summary available',
            short: false
          }
        ],
        footer: 'Sifter 1.2',
        ts: Math.floor(Date.now() / 1000)
      }]
    };
  }

  private static formatForTeams(data: any): any {
    return {
      "@type": "MessageCard",
      "@context": "http://schema.org/extensions",
      "themeColor": "0076D7",
      "summary": `Sifter Analysis: ${data.displayName}`,
      "sections": [{
        "activityTitle": `ðŸ”¬ Sifter Analysis: ${data.displayName}`,
        "activitySubtitle": `Risk Score: ${data.overallRisk.score}/100`,
        "facts": [
          {
            "name": "Verdict",
            "value": data.overallRisk.verdict.toUpperCase()
          },
          {
            "name": "Confidence",
            "value": `${data.overallRisk.confidence}%`
          }
        ],
        "text": data.overallRisk.summary || 'No summary available'
      }]
    };
  }

  // ============= HELPER METHODS =============
  private static escapeCSVValue(value: any): string {
    if (value == null) return '';
    
    const stringValue = String(value);
    
    // Escape quotes and wrap in quotes if contains commas, quotes, or newlines
    if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
      return `"${stringValue.replace(/"/g, '""')}"`;
    }
    
    return stringValue;
  }

  private static sanitizeFilename(filename: string): string {
    return filename
      .replace(/[^a-z0-9]/gi, '_')
      .toLowerCase()
      .replace(/_+/g, '_')
      .replace(/^_+|_+$/g, '');
  }

  private static formatMetricName(metricKey: string): string {
    const names: Record<string, string> = {
      teamIdentity: 'Team Identity',
      teamCompetence: 'Team Competence',
      contaminatedNetwork: 'Contaminated Network',
      mercenaryKeywords: 'Mercenary Keywords',
      messageTimeEntropy: 'Message Time Entropy',
      accountAgeEntropy: 'Account Age Entropy',
      tweetFocus: 'Tweet Focus',
      githubAuthenticity: 'GitHub Authenticity',
      busFactor: 'Bus Factor',
      artificialHype: 'Artificial Hype',
      founderDistraction: 'Founder Distraction',
      engagementAuthenticity: 'Engagement Authenticity',
      tokenomics: 'Tokenomics'
    };
    
    return names[metricKey] || metricKey.replace(/([A-Z])/g, ' $1').trim();
  }

  private static getMetricWeight(metricName: string): number {
    const weights: Record<string, number> = {
      teamIdentity: 13,
      teamCompetence: 11,
      contaminatedNetwork: 19,
      mercenaryKeywords: 9,
      messageTimeEntropy: 5,
      accountAgeEntropy: 5,
      tweetFocus: 7,
      githubAuthenticity: 10,
      busFactor: 2,
      artificialHype: 5,
      founderDistraction: 6,
      engagementAuthenticity: 10,
      tokenomics: 7
    };
    
    return weights[metricName] || 0;
  }

  private static getRecommendationFromScore(score: number): string {
    if (score >= 80) return 'DO NOT INVEST - High probability of scam';
    if (score >= 60) return 'HIGH RISK - Extreme caution advised';
    if (score >= 40) return 'MODERATE RISK - Additional research needed';
    if (score >= 20) return 'LOW RISK - Standard due diligence';
    return 'VERY LOW RISK - Appears legitimate';
  }

  // ============= SHARE FUNCTIONALITY =============
  static async shareAnalysis(projectData: ProjectData, platform?: 'twitter' | 'linkedin' | 'clipboard'): Promise<boolean> {
    const shareText = `Sifter Analysis: ${projectData.displayName}\nRisk Score: ${projectData.overallRisk.score}/100 (${projectData.overallRisk.verdict.toUpperCase()})\n${projectData.overallRisk.summary || ''}`;
    const shareUrl = window.location.href;

    try {
      switch (platform) {
        case 'twitter':
          const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`;
          window.open(twitterUrl, '_blank', 'noopener,noreferrer');
          return true;
          
        case 'linkedin':
          const linkedinUrl = `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(shareUrl)}`;
          window.open(linkedinUrl, '_blank', 'noopener,noreferrer');
          return true;
          
        case 'clipboard':
        default:
          try {
            await navigator.clipboard.writeText(`${shareText}\n\n${shareUrl}`);
            return true;
          } catch (err) {
            console.error('Failed to copy:', err);
            // Fallback to textarea method
            const textArea = document.createElement('textarea');
            textArea.value = `${shareText}\n\n${shareUrl}`;
            document.body.appendChild(textArea);
            textArea.select();
            const success = document.execCommand('copy');
            document.body.removeChild(textArea);
            return success;
          }
      }
    } catch (error) {
      console.error('Share failed:', error);
      return false;
    }
  }

  // ============= BULK EXPORT =============
  static exportAllAnalyses(projects: ProjectData[]): void {
    if (!projects || projects.length === 0) {
      console.error('No projects to export');
      return;
    }

    // Export summary CSV
    const summaryRows = projects.map(project => ({
      Project: project.displayName,
      'Risk Score': project.overallRisk.score,
      Verdict: project.overallRisk.verdict.toUpperCase(),
      'Processing Time': `${project.processingTime}ms`,
      'Scanned At': project.scannedAt?.toISOString() || new Date().toISOString()
    }));

    this.exportToCSV(summaryRows, `all_analyses_summary_${new Date().toISOString().split('T')[0]}.csv`);

    // Export combined JSON
    const combinedData = {
      metadata: {
        totalProjects: projects.length,
        averageRiskScore: Math.round(projects.reduce((sum, p) => sum + p.overallRisk.score, 0) / projects.length),
        generatedAt: new Date().toISOString(),
        version: 'Sifter 1.2'
      },
      projects: projects.map(p => ({
        name: p.displayName,
        riskScore: p.overallRisk.score,
        verdict: p.overallRisk.verdict,
        metrics: p.metrics
      }))
    };

    this.exportToJSON(combinedData, `all_analyses_combined_${new Date().toISOString().split('T')[0]}.json`);
  }
}